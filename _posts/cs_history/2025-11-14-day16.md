---
title:  "Day 16: 컴퓨터가 스스로 프로그램을 쓰기 시작하다"
categories:
  - cs_history
toc: true
toc_sticky: true
comments: true
---

컴퓨터 과학의 새벽, 기계와 대화하는 유일한 방법은 0과 1의 언어, 즉 기계어뿐이었습니다. 이는 극소수의 전문가만이 해독하고 작성할 수 있는 암호와도 같았죠. 오늘 우리는 이 장벽을 허물기 시작한 최초의 번역가, 그레이스 호퍼의 A-0 컴파일러를 만나봅니다.

## 🕰️ 오늘의 키워드: A-0 컴파일러(A-0 Compiler)
 * 원어: A-0 System (Arithmetic Language version 0)
 * 시기: 1952년 (그레이스 호퍼(Grace Hopper)가 UNIVAC I 컴퓨터용으로 개발)

1952년, 미 해군 장교이자 수학자였던 그레이스 호퍼는 프로그래밍의 패러다임을 영원히 바꿀 아이디어를 현실로 옮겼습니다. 그녀가 개발한 A-0 시스템은 역사상 최초의 컴파일러로 인정받는 프로그램입니다. 당시 프로그래머들은 재사용 가능한 코드 조각, 즉 서브루틴(subroutine)을 수동으로 복사하고 메모리 주소를 일일이 계산하여 프로그램에 삽입하는 고된 작업을 반복했습니다. 호퍼는 이 과정을 컴퓨터가 대신하도록 만들었습니다. A-0 시스템은 프로그래머가 작성한 상위 수준의 수학적 기호 코드를 컴퓨터가 직접 실행할 수 있는 기계어로 번역해주는 역할을 했습니다.

## ⚡ 무엇이 혁명적이었나? (Deep Dive)
A-0 시스템의 혁명성은 '자동화'라는 개념에 있습니다. 현대적 의미의 컴파일러처럼 복잡한 구문 분석이나 최적화를 수행하지는 않았지만, 당시로서는 상상하기 어려운 일을 해냈습니다. 기술적으로 A-0는 오늘날의 '링커(linker)'나 '로더(loader)'에 더 가깝게 동작했습니다.

작동 방식은 다음과 같았습니다:
1.  **서브루틴 라이브러리:** 호퍼는 자주 사용되는 서브루틴들을 자기 테이프에 저장하고, 각각에 고유한 숫자 코드(call number)를 부여했습니다.
2.  **소스 코드 작성:** 프로그래머는 프로그램을 작성할 때, 필요한 서브루틴의 숫자 코드와 인자(argument)들을 순서대로 나열하기만 하면 됐습니다.
3.  **컴파일(Compile):** A-0 시스템은 이 소스 코드를 읽어 들여, 자기 테이프에서 해당 숫자 코드의 서브루틴을 찾아 메모리의 올바른 위치로 복사했습니다. 이 과정에서 필요한 주소 재배치까지 자동으로 수행했습니다.
4.  **실행 파일 생성:** 모든 서브루틴이 결합되면, 컴퓨터에서 바로 실행할 수 있는 완전한 기계어 프로그램이 만들어졌습니다.

이전까지 프로그래머들은 서브루틴을 복사하다 실수를 하거나, 주소 계산을 잘못하여 몇 시간, 며칠을 디버깅에 허비했습니다. A-0는 이 지루하고 오류 발생률이 높은 수작업을 기계에 맡김으로써, 프로그래머가 문제 해결의 본질에 더 집중할 수 있도록 해방시켰습니다. 이는 '컴퓨터가 단순히 계산만 하는 기계가 아니라, 프로그래밍이라는 지적 작업을 돕는 도구가 될 수 있다'는 인식의 전환을 가져온 결정적 사건이었습니다.

## 🔗 현대와의 연결: 소프트웨어 개발 도구의 시조
A-0 시스템은 현대 소프트웨어 개발 환경의 근간을 이루는 모든 기술의 직계 조상입니다. 우리가 사용하는 모든 프로그래밍 언어는 컴파일러나 인터프리터를 통해 컴퓨터가 이해할 수 있는 언어로 번역됩니다. C++, Java, Python 등의 언어로 작성된 코드가 스마트폰 앱이나 웹 서버에서 동작할 수 있는 것은 모두 A-0이 개척한 '고급 언어 -> 기계어' 번역 개념 덕분입니다.

*   **컴파일러(Compiler):** A-0는 소스 코드 전체를 기계어로 번역하는 현대 컴파일러의 원시적인 형태였습니다. GCC, Clang, MSVC와 같은 현대 컴파일러들은 A-0의 기본 아이디어에 구문 분석, 의미 분석, 코드 최적화 등 훨씬 정교한 기술을 더한 것입니다.
*   **링커(Linker) 및 라이브러리(Library):** A-0가 자기 테이프에서 서브루틴을 가져와 연결한 것처럼, 현대의 링커는 우리가 작성한 코드와 미리 컴파일된 라이브러리(.lib, .a, .so, .dll 파일 등)를 연결하여 최종 실행 파일을 만듭니다. 우리가 `printf()`나 `import math` 같은 함수를 간단히 호출할 수 있는 것도 이러한 라이브러리와 링킹 과정이 있기 때문입니다.

결론적으로, 그레이스 호퍼의 A-0는 인간이 기계에 맞춰 생각하던 방식에서 벗어나, 기계가 인간의 언어에 더 가깝게 다가오도록 만든 최초의 위대한 발걸음이었습니다.

## 📅 내일의 키워드 예고
그레이스 호퍼가 프로그래밍의 '자동화'라는 문을 열었다면, 이제 과학자와 엔지니어들이 직접 자신의 언어로 컴퓨터와 대화할 수 있는 시대가 열릴 차례였습니다. 내일은 IBM의 한 연구팀이 대수학 공식처럼 보이는 언어로 컴퓨터 프로그램을 작성하려는 야심 찬 도전을 시작합니다. 최초의 상업적으로 성공한 고급 프로그래밍 언어, 'FORTRAN'의 탄생을 함께 지켜보시죠.

## 📚 참고 문헌
* [computinghistory.org.uk](https://www.computinghistory.org.uk/det/5487/Grace-Hopper-completes-the-A-0-Compiler/)
* [yale.edu](https://president.yale.edu/biography-grace-murray-hopper)
* [howdy.com](https://vertexaisearch.cloud.google.com/grounding-api-redirect/AUZIYQHv8dOwGyWS9ypD3KSxbKpoF6I-YtBx-D4zKT_f8osmuKtDG7XeuLzF3m6sd28D2VXojADQTrKTfLgXsg3-ae9F_JDhVtUxDCWFv78cFiO7V45JbJLhOfoFYHJjgnc7CQf8iBFEkQ_s)
* [innovation.world](https://innovation.world/es/invention/a-0-system/)
* [acm.org](https://vertexaisearch.cloud.google.com/grounding-api-redirect/AUZIYQG9AAY1c7KCR9MKQdZ4BBRwuwzXSdngscRNIcrl361fV7DAt2QKva-g2ITff04eEKB8kLPE95ts2lA8bVkoxBkAMQzUsh2sLj_XYsl6RA3UIp9QUDSihvX_si4vZKIDBxtmfmyrIG0whGpmTDc47ZQdbsQhXmqRBAWvmcWPHCCZEX4E8A==)
* [innovation.world](https://innovation.world/invention/a-0-system/)
* [stanford.edu](https://web.stanford.edu/class/cs208e/cgi-bin/main.cgi/static/lectures/17-ProgrammingEarlyDays/EarlyProgrammingLanguages.pdf)
* [wikipedia.org](https://en.wikipedia.org/wiki/A-0_System)
* [quora.com](https://vertexaisearch.cloud.google.com/grounding-api-redirect/AUZIYQFEqrGzMaS8BnUeLuwOwKkiroADVHrLLewCEG4ck2EfnU6w0gODgyxNMKtEHg936NGZca9Mt_ygtgcSq3tFw1cb7WVetMjsXyxKeGOfdRP3DjWCeERzeJMT-OvmCn6krrEU1HPB83de4vuA-zhqj_KOk2Tg78cwEhqhHoTrsQ==)


*이 콘텐츠는 AI에 의해 생성되었으며, 오류나 부정확한 정보를 포함할 수 있습니다.*